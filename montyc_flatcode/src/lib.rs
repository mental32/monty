//! A post-processed, flattened, AST, with extra semantics sprinkled in.
//!
//! Typically generated immedietly after parsing and passed around to verious
//! semantic passes, i.e. static type checking or to the const interpreter.
//!
#![warn(dead_code)]
#![deny(warnings)]

mod lower;
mod tests;

pub mod raw_inst;

use std::fmt::Display;

use montyc_ast::Constant;
use montyc_core_types::module::ModuleRef;
use montyc_lexer::{Span, SpanRef};
use montyc_parser::prelude::*;

use self::raw_inst::RawInst;

const INVALID_VALUE: usize = std::usize::MAX;

/// associated attributes of an instruction.
#[derive(Debug, Clone, Default)]
pub struct InstAttrs {
    pub span: Option<Span>,
    pub ast: Option<AstNode>,
}

/// An instruction in a sequence of code and it's output value.
#[derive(Debug, Clone)]
pub struct FlatInst<V = usize, R = SpanRef> {
    pub op: RawInst<V, R>,
    pub value: V,
    pub attrs: InstAttrs,
}

#[allow(missing_docs)]
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum SequenceType {
    Module,
    Class,
    Function,
}

/// A sequence of flatcode.
#[derive(Debug, Clone)]
pub struct FlatSeq {
    pub(crate) inst: Vec<FlatInst>,
    pub kind: SequenceType,
    pub span: (ModuleRef, Span),
    pub ast: Option<AstNode>,
}

impl<'a> IntoIterator for &'a FlatSeq {
    type Item = FlatInst;

    type IntoIter = <Vec<FlatInst> as IntoIterator>::IntoIter;

    fn into_iter(self) -> Self::IntoIter {
        self.inst.clone().into_iter()
    }
}

impl FlatSeq {
    #[inline]
    pub fn inst(&self) -> &[FlatInst] {
        self.inst.as_slice()
    }

    #[inline]
    pub fn inst_mut(&mut self) -> &mut [FlatInst] {
        self.inst.as_mut_slice()
    }

    /// true if the body of the sequence consists of only an ellipsis or a string, followed by an ellipsis.
    #[inline]
    pub fn is_stubbed(&self) -> bool {
        match self.inst() {
            [single] => matches!(single.op, RawInst::Const(Constant::Ellipsis)),
            [first, second] => {
                matches!(second.op, RawInst::Const(Constant::Ellipsis))
                    && matches!(first.op, RawInst::Const(Constant::String(_)))
            }

            _ => false,
        }
    }
}

/// An SSA-based, linear, sequence of code-like IR generated by flattening an AST.
#[derive(Debug, Clone)]
pub struct FlatCode {
    sequence_index: usize,
    pub mref: ModuleRef,
    pub(crate) sequences: Vec<FlatSeq>,
}

impl Display for FlatCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for (s, sequence) in self.sequences.iter().enumerate() {
            write!(f, "sequence({}):\n", s)?;

            for inst in sequence.inst.iter() {
                write!(f, "  %{} = {}\n", inst.value, inst.op)?;
            }
        }

        Ok(())
    }
}

impl FlatCode {
    fn inst(&mut self, raw_inst: RawInst) -> usize {
        match self.sequences.get_mut(self.sequence_index) {
            Some(FlatSeq { inst: seq, .. }) => {
                seq.push(FlatInst {
                    op: raw_inst,
                    value: seq.len(),
                    attrs: InstAttrs::default(),
                });

                seq.len().saturating_sub(1)
            }

            None => unreachable!(),
        }
    }

    fn last_inst(&self) -> Option<&FlatInst> {
        self.sequences.get(self.sequence_index)?.inst.last()
    }

    #[track_caller]
    fn set_span_for_values<A>(&mut self, values: A, span: Span)
    where
        A: AsRef<[usize]>,
    {
        let seq = &mut self.sequences[self.sequence_index];

        for value in values.as_ref() {
            seq.inst[*value].attrs.span.replace(span.clone());
        }
    }

    #[track_caller]
    fn with_new_sequence(
        &mut self,
        size_hint: usize,
        kind: SequenceType,
        span: (ModuleRef, Span),
        f: impl FnOnce(&mut Self),
    ) -> usize {
        let old_index = self.sequence_index;

        self.sequence_index = self.sequences.len();
        self.sequences.push(FlatSeq {
            inst: Vec::with_capacity(size_hint),
            kind,
            ast: None,
            span,
        });

        assert!(self.sequences.get(self.sequence_index).is_some());

        let index = self.sequence_index;

        f(self);

        self.sequence_index = old_index;
        index
    }
}

impl FlatCode {
    /// Creat a new flatcode builder.
    pub fn new(span: (ModuleRef, Span)) -> Self {
        Self {
            sequence_index: 0,
            mref: span.0.clone(),
            sequences: vec![FlatSeq {
                inst: vec![],
                kind: SequenceType::Module,
                ast: None,
                span,
            }],
        }
    }

    /// The associated ModuleRef with this code.
    pub fn mref(&self) -> ModuleRef {
        self.mref
    }

    /// The sequences of the code.
    pub fn sequences(&self) -> &[FlatSeq] {
        &self.sequences
    }

    /// Check if the given sequence only has an ellipsis instruction inside it.
    pub fn is_sequence_ellipsis_stubbed(&self, seq: usize) -> bool {
        self.sequences
            .get(seq)
            .map(|seq| {
                matches!(
                    seq.inst.as_slice(),
                    [FlatInst {
                        op: RawInst::Const(Constant::Ellipsis),
                        ..
                    }]
                )
            })
            .unwrap_or(false)
    }
}
